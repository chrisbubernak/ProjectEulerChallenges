# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the
# following formulae:

# Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	P4,n=n2	 	        1, 4, 9, 16, 25, ...
# Pentagonal	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

# The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal,
# and octagonal, is represented by a different number in the set.

import math

# sets for quick look ups
triangles = set()
squares = set()
pentagonals = set()
hexagonals = set()
heptagonals = set()
ocatagonals = set()

# key is the first two digits, value is a set of all the numbers that meet this criteria
prefix = dict()

# key is the last two digits, value is a set of all the numbers that meet this criteria
suffix = dict()

# adds a number to the prefix and suffix dicts
def addPrefixSuffix(n):
  p = str(n)[0:2]
  s = str(n)[-2:] 
  if not(p in prefix):
    prefix[p] = set()
  prefix[p].add(n)

  if not(s in suffix):
    suffix[s] = set()
  suffix[s].add(n)

# numbers with a 0 in the 2nd to last digit can never be chained
# so ignore them
def isValid(n):
  return not(str(n)[-2] == '0') and len(str(n)) == 4

# fills the sets and dicts
def fillSets():
  # bounds of i from 19 - 141 will generate all 4 digit numbers
  for i in range(19, 141):
    t = int((i * (i+1)) / 2)
    if isValid(t):
      triangles.add(t)
      addPrefixSuffix(t)
  
    s = int(i * i)
    if isValid(s):
      squares.add(s)
      addPrefixSuffix(s)

    p = int(i * ((3 * i) - 1) / 2)
    if isValid(p):
      pentagonals.add(p)
      addPrefixSuffix(p)
    
    hx = int(i * ((2 * i) -1))
    if isValid(hx):
      hexagonals.add(hx)
      addPrefixSuffix(hx)
    
    hp = int(i * ((5 * i) - 3) / 2)
    if isValid(hp):
      heptagonals.add(hp)
      addPrefixSuffix(hp)
    
    o = int(i * ((3 * i) - 2))
    if isValid(o):
      ocatagonals.add(o)
      addPrefixSuffix(o)

    i = i + 1

# given a list of 6 six numbers make sure one of each num type is represented
def check(nums):
  # first make sure the first prefix matches the last suffix 
  if not(((str(nums[0])[0:2] ==str(nums[-1])[-2:]))):
    return False

  # then make sure all num types are represented  
  t = False
  s = False
  p = False
  hx = False
  hp = False
  o = False
  for n in nums:
    if (n in ocatagonals):
      o = True
    elif (n in heptagonals):
      hp = True
    elif n in hexagonals:
      hx = True
    elif (n in pentagonals):
      p = True
    elif (n in squares):
      s = True
    elif (n in triangles):
      t = True
  return t == True and s == True and p == True and hx == True and hp == True and o == True

# creates an array of number chains starting with a seed value, it terminates the chains
# when they reach length 6
def chain(n):
  q = [[n]]
  while len(q) > 0 and len(q[0]) < 6:
    newQ = []
    for chain in q:
      # get the suffix of the last item
      s = str(chain[-1])[-2:]
      if s in prefix:
        for p in prefix[s]:
          if not(p in chain):
            newQ.append(chain + [p])
    q = newQ
  return q

def solve():
  # puts all 4 digits into sets (triangular, square, pentagonal, etc)
  # as well as creates a prefix and suffix dict for quick look up
  fillSets()
  for i in list(squares):
    for c in chain(i):
      if (check(c)):
        return sum(c)

print(solve())
